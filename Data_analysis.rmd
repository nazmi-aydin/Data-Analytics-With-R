---
title: "Analysis"
author: "Nazmi Aydın"
date: "21 02 2022"
output: github_document
---

This Exploratory Data Analytics Project aims to analyze "googleplaystore.csv" data which includes the Google Play Store apps with the help of RStudio. The "googleplaystore.csv" data includes 13 variables which are App Name, Category, Rating, Reviews, Size, Installs, Type, Price, Content.Rating, Genres, Last.Updated, Current.Ver, Android.Ver. To analyze the data, I find the appropriate needs such as one-variable and two-variable plots, an applicable model such as linear regression, logical regression or naive bayes. Before the analysis, with the help of tidyverse package, I did some data cleaning to interpret the plots and regression as in its correct way. To interpret the plots, I use ggplot2 package. My plots has based on Category, Reviews, Rating and App Types. The results and plots were stated below the report.
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Reading the Packages
In this project, I used ggplot2 and tidy verse packages to build the plots. ggplot2 package was used to create the basis of the plots and tidyverse package was used to convert some categorical variables to numerical variables. 
```{r}
library(ggplot2)

library(tidyverse)

library(e1071)

```

## Reading The Data

```{r}
setwd("C:/Users/Mbappe from Niğde/Downloads")
getwd()
apps <- read.csv("googleplaystore.csv")
str(apps)
summary(apps)
```

## Data Cleaning And Correcting Data Types 

First of all, I need to clean our data from some non-numeric signs which are "+", "+", "," and etc. Otherwise,I may have some problems making plots in R.
* In googleplaystore dataset, before I converted some chr variable into num variable, there were ***12*** ***chr*** and ***1*** ***num*** variable. 
* After I converted ***3*** of the ***chr*** variable to ***num*** variable, I have ***12*** ***chr*** and ***4*** ***num*** variable. 
* I did this convertion to apply ggplot package more clearly and correctly.

```{r}

apps$Reviews_num <- as.numeric(apps$Reviews)

apps$Price_num2 <- as.numeric(gsub("[//$,]", "", apps$Price))

apps$Installs_num <- as.numeric(gsub("[//+,]", "", apps$Installs))

apps$Type_Na <- na.omit(apps$Type)

new_df <-apps %>%
  filter(str_detect(Genres, "0"))


apps <- apps[-c(9149),]
apps <- apps[-c(10473),]
str(apps)
apps <- na.omit(apps)

```


## Distribution of App Categories

#### The aim of choosing this plot
Google Play Store separates apps into categories. To make our analysis stronger we have to answers these questions:

Which category is the most active in the market?

Is any particular category dominating the market?

Which categories have the smallest number of apps?

There are ***33*** categories in my data set in present. The categories which are ***Family*** and ***Game*** have the highest market popularity. Surprisingly, ***Business***, ***Medical*** and ***Tools*** categories are popular. However, also surprisingly, the category ***Shopping*** has a not considerable count. In addition, I think that the number of apps in category ***Medical*** is considerable because of the ****COVID-19*** situation. As an example, there are a lot of medical apps such as HES and E-Nabız. However, for the ***Shopping*** category, I can bound the reason behind of this reasonable number to ***COVID-19***. The interpretation of the Category section has placed on y-axis to see all of them more precisely.

```{r echo = TRUE, fig.cap = " Figure 1: Distribution of App Categories"}
plot(ggplot(aes(x= , y=Category ), data = apps) + 
  xlab("Number of Apps") +
  ylab("Category") +
  geom_bar(width = 0.5) 
)

```


## Distribution of Reviews

In the histogram, I see that the distribution is ***right skewed*** which means that not all apps in our data has large number of views. I found this information interesting because I think that the number of the large viewed applications would be more. The reason behind is that in our generation, we have a huge application pool and a huge percentage of the app companies making advertisements of their apps on YouTube, Tiktok, Twitter, Instagram, etc. everyday.

```{r echo = TRUE, fig.cap = " Figure 2: Distribution of Reviews"}
plot(ggplot(aes(x =Reviews_num), data = subset(apps)) + 
  geom_histogram(color = "black", fill = "blue") + 
  scale_x_continuous(limits = c(0,10000), breaks = seq(0, 10000, 500)) + 
  scale_y_continuous(limits = c(0,800))+
  ylab("Total Number")+
  xlab("Reviews Distribution"))
  

```

## Distribution of Rating

#### The aim of choosing this plot
To see the rating distribution of this data. If the general rating percentage high, the Google Play Store users are very enjoying many of the apps in the app pool, but of course not all of them. 

In this plot, it has seen that the graph is left-skewed. You might also notice that there is a gap between 0-1.2 and 1.2-1.4. The reason why is that the "count" variable has a very low value in these interval. In general, the apps are highly rated by the users. New apps that are released are likely to have high ratings unless there is a notable exception. 
* In order to see more clearly, interpretation of the histogram were made with red color.
* Additionally, the y-axis' limit has stabled in the value 1200. If the limit of the y-axis is more than 1200, it has seen that more intervals in x-axis might dissapear. 

```{r echo = TRUE, fig.cap = " Figure 3: Distribution of Rating"}
plot(ggplot(aes(x = Rating), data = subset(apps)) + 
  geom_bar(color = "black", fill = "red") + 
  xlab("Rating Distribution") +
  ylab("Number of Ratings") +
  scale_x_continuous(limits = c(2.35,5), breaks = seq(2.35, 5, 0.2)) + 
  scale_y_continuous(limits = c(0,1200)) +
  coord_trans(x = "sqrt"))
```


### Popularity of Paid apps vs Free Apss

#### The aim of choosing this plot
To have a general knowledge of the popularity of the paying status of the apps. Does it make more sense to make the app paid?


There are 5 pricing options available in the Google Play Store Market which are: "Freemium", "Paymium" "Paid", "Free" and "Subscription". In this box plot, I only include "Free", "Paid" to have a perspective about paying or not paying for the apps.

I found that paid apps have fewer installs than free apps, however, the difference is not as significant as we would be expected.

```{r echo = TRUE, fig.cap = " Figure 4: Popularity of Paid apps vs. Free Apps"}
plot(ggplot(aes(x= Type_Na , y= Installs_num), data = apps) + geom_boxplot() + 
  xlab("App Types") +
  ylab("Number of Installs") +
  scale_y_continuous(limits = c(1,10000), breaks = c(1, 10000, 1000)))

```

### Reviews Number vs. Rating 

#### The aim of choosing this plot
I choose this graph to analyze if the high rated apps has large number of views, or the opposite, if the app has large number of views, is it low rated.

In this two variable plot, it is seen that the distribution is ***left-skewed.*** While plotting the ***non-sqrt*** one of this plot, we have struggled to observe and analyze the distribution and relationship. To detect and analyze and make comments about the distribution more properly and correctly, I converted our function to ***sqrt.*** There are some ***outliers*** at the ending part of our distribution. 

```{r echo = TRUE, fig.cap = " Figure 5: Reviews Number vs. Rating"}
plot(ggplot(aes(x =Rating, y = Reviews_num), data = apps) + 
  geom_point() +
  xlab("Distribution of Ratings") + 
  ylab("Number of Reviews") +
  scale_x_continuous(limits = c(1,5), breaks = seq(1, 5, 0.2)) + 
  scale_y_continuous(limits = c(0,1.1e+07)) + 
  coord_trans(y = "sqrt"))
```


### Rating vs Price 

#### The aim of choosing this plot

I decided to do the Rating vs. Price because if the apps which has high price has a good rating(or lets say feedback) from the users. 

In this two variable plot, I observed the Rating(x-axis) and Price(y-axis). The distribution looked more of a ***left-skewed.*** In order to see the distribution between the intervals 1.2-3.8, I limit the y-axis to 50. I also observed that prices of the apps gets bigger when their ratings are getting bigger. 

* Additionally, ***sqrt*** function is used on the plots to see the distribution more clear. 

```{r echo = TRUE, fig.cap = " Figure 6: Rating vs. Price"}
plot(ggplot(aes(x =Rating, y = Price_num2), data = apps) + 
  geom_point() +
  xlab("Distribution of Ratings") + 
  ylab("App Prices in Dollars") +
  scale_x_continuous(limits = c(1, 5), breaks = seq(1, 5, 0.2)) +
  scale_y_continuous(limits = c(0,15), breaks = c(0, 15, 5)) + 
  coord_trans(y = "sqrt"))
```
### Variable Conversion for Naive Bayes 

I converted the Installs, Type of Apps, Rating, Content Rating, Price of Apps to factor variable to apply Naive Bayes.

```{r}
unique(apps$Installs)
apps$Installs <- factor(apps$Installs)
a <- table(apps$Installs)
str(apps$Installs)
apps$Genres <- factor(apps$Genres)
apps$Category <- factor(apps$Category)
apps$Type_Na <- factor(apps$Type_Na)
apps$Content.Rating <- factor(apps$Content.Rating)
apps$Reviews <- factor(apps$Reviews)
```
### Naive Bayes 

I observed that:

The apps which has higher than 50 million Installs (excluding 100 million) are Free.

On the interval between 10k and 1m Installs, high portion of the apps are also Free (97.5%, 91%).

```{r}
xtabs(~Installs_num + Type_Na , data = apps)

apps2 <- with(apps, data.frame(Installs_num = Installs_num, Type_Na = Type_Na, Content.Rating = Content.Rating, Price_num2 = Price_num2 ))

s <- sample(nrow(apps2),nrow(apps2)*.8)
training_set <- apps[s,]
test_set <- apps[-s,]

nb_model1 <- naiveBayes(Installs_num ~ Type_Na + Rating + Content.Rating + Price_num2, data = training_set)
nb_model1

prediction <- predict(nb_model1, test_set[,-1])
head(cbind(prediction, test_set$Installs_num))
table(prediction, test_set$Installs_num)

```

###Linear Regression

In the Linear Regression, I analyzed Number of Installs by Cost Type(Free-Paid), Genres, Price, Category, Rating and Number of Reviews. With the usage of backward, forward and both way selection, ***R-squared*** and ***Adjusted R-squared*** values were as ***0.4305*** and ***0.4283*** which is not high enough for a meaningful relationship. Additionally the ***p-value*** was ***2.2e-16***. As shown in the summary part, many of the independent variables have higher p-value than 0.05.

```{r}
max_model <- lm(Installs_num~Type_Na+Genres+Price_num2+Category+Rating+Reviews_num, data=apps)
summary(max_model)

bckw_model <- step(max_model, direction = "backward")
summary(bckw_model)

min_model <- lm(Rating~1, data = apps)
summary(min_model)

fwd_model<- step(min_model, direction = 'forward', scope= list(lower=min_model, upper= max_model))

summary(fwd_model)

both_model <- step(max_model, direction = 'both')
summary(both_model)

```


